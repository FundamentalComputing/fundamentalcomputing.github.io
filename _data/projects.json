[
    {
        "title": "A survey of graph parameters and their comparison",
        "supervisor": {
            "name": "Ivan Bliznets",
            "email": "i.bliznets@rug.nl"
        },
        "short_description": "Explore the intricate world of graph parameters and their relationships, from treewidth to vertex cover, to gain deeper insights into algorithmic complexity.",
        "long_description": "
Graphs are the backbone of computer science, and they are everywhere! They are used to model a wide variety of real-world problems, including social networks, transportation networks, and communication networks. Graphs have many parameters that describe their complexity and structure, and these parameters can be used to gain insights into the underlying problem. The simplest such parameters are the number of vertices and the number of edges, but there are more involved parameters like treewidth. This parameter describes how significantly a graph is different from a tree (see the <a href=\"https://en.wikipedia.org/wiki/Treewidth\" target=\"_blank\">Wikipedia page for Treewidth</a> for more details). There are many other parameters like pathwidth, cliquewidth, twinwidth, vertex cover, neighborhood diversity, and so on.  All these parameters can be used to gain a deeper understanding of how hard a particular problem is on a given graph.


The goal of the proposed project is to survey and study relations between different parameters describing graphs. For example, it is well known that the pathwidth parameter is never smaller than a treewidth. It is expected that this kind of relations will be surveyed or discovered in the project. Also you will be exploring different graph parameters from the viewpoint of algorithms and discrete mathematics. The project is an exciting opportunity to dive deep into the world of graphs and algorithms.


If you want to know more about treewidth you can watch <a href=\"https://www.youtube.com/watch?v=kEnDGTwSDXY\" target=\"_blank\">this video</a> (understanding all material in the video is NOT necessary)

This project is intended for students interested in graphs.",
        "tags": ["algorithms", "graphs"],
        "category": "BSc",
        "available": 2
    },

    {
        "title": "NP-complete number theoretical problems",
        "supervisor": {
            "name": "Ivan Bliznets",
            "email": "i.bliznets@rug.nl"
        },
        "short_description": "Discover if problems involving number theoretical aspects, like covering arrays with arithmetic progressions, exhibit similar complexity shifts when transitioning from integer to rational inputs.",
        "long_description": "
Subset sum, knapsack, and partition are well-known problems in computer science. These problems involve a list of numbers as input. If the input contains only integer numbers, these problems are weakly NP-complete and admit pseudo polynomial algorithms. However, if the input contains rational numbers given by the denominator and numerator, these problems become strongly NP-complete.


The goal of this project is to investigate whether other “number theoretical” NP-complete problems have similar behavior. One such problem is the problem of covering the input array by the smallest number of arithmetic progressions. It is known that this problem is weakly NP-complete if the input contains only integer numbers. The proof of this result and other details can be found in [this paper](https://www.sciencedirect.com/science/article/abs/pii/002001909090013N).


For additional information on this topic see [this paper](https://arxiv.org/abs/1802.09465).


This project is intended for students interested in algorithms, NP-completeness and introductory number theory.
",
        "tags": ["algorithms", "complexity"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "Interplay of number theory and fixed-parameter tractable algorithms",
        "supervisor": {
            "name": "Ivan Bliznets",
            "email": "i.bliznets@rug.nl"
        },
        "short_description": "Explore the potential of parameterized complexity to design efficient algorithms for computationally hard number theory problems, focusing on identifying problems with real-world parameters that allow for efficient solutions.",
        "long_description": "
Parameterized complexity is a promising approach to tackle computationally hard problems. So far, fixed-parameter tractable algorithms have been designed mainly for graph problems. The goal of this project is to study the possibility of the application of fixed-parameter tractable machinery to the construction of efficient algorithms for computationally hard problems from basic number theory.


The project starts with a study of basic notions and definitions of fixed-parameter tractable algorithms. The final goal of the project is to survey  NP-complete problems involving integer numbers that might have small parameters (some characteristics) in real-world instances. For example, in the CAP problem, an input consists of a set of integer numbers, and the goal is to cover all these numbers using the smallest number of arithmetic progressions that do not include other integers. It is natural to assume that, in real life, we are interested in answers only if the number of arithmetic progressions is small. Under such parameterization, CAP admits an efficient algorithm (the problem has a fixed-parameter tractable algorithm), even though the general case of CAP is NP-complete.


During the project, your goal is to identify problems from basic number theory that are interesting from the point of view of fixed-parameter tractable algorithms.

Literature:

  - Basics of parameterized algorithms: Chapters 1 and 3 in the book \"Parameterized Algorithms\", available [here](https://www.mimuw.edu.pl/~malcin/book/parameterized-algorithms.pdf)

  - [List of NP-complete problems](https://en.wikipedia.org/wiki/List_of_NP-complete_problems)
",
        "tags": ["algorithms", "complexity"],
        "category": "BSc",
        "available": 2
    },

    {
        "title": "The Partial Minimum Satisfiability problem",
        "supervisor": {
            "name": "Ivan Bliznets",
            "email": "i.bliznets@rug.nl"
        },
        "short_description": "Design and implement a branch-and-bound algorithm for the Partial Minimum Satisfiability problem, tackling the challenge of finding satisfying assignments while minimizing the number of satisfied clauses.",
        "long_description": "
The Partial Minimum Satisfiability problem involves a CNF formula F, where some of the clauses are marked as hard clauses. The goal is to find a satisfying assignment that satisfies all hard clauses and the smallest number of other clauses. The length of the formula is defined as the number of literals in the formula. The objective of this project is to construct an algorithm for the Partial Minimum Satisfiability problem, with the running time measured in terms of the length of the formula or in terms of the overall number of variables and clauses. The algorithm will most likely be a branch-and-bound algorithm. You can find details about branching algorithms in Chapter 2 of the book [Exact Exponential Algorithms](https://folk.uib.no/nmiff/BookEA/BookEA.pdf).


This project will introduce you to exact exponential algorithms and basic techniques for designing such algorithms. You will also have the opportunity to construct your own algorithm for the Partial Minimum Satisfiability problem. Good luck!


Literature:

- [Exact Exponential Algorithms](https://folk.uib.no/nmiff/BookEA/BookEA.pdf)

- [Description of the Partial Minimum Satisfiability problem and its applications.](https://www.sciencedirect.com/science/article/pii/S0004370212000616)
",
        "tags": ["algorithms"],
        "category": "BSc",
        "available": 2
    },

    {
        "title": "Minimal Connected Tropical Sets",
        "supervisor": {
            "name": "Ivan Bliznets",
            "email": "i.bliznets@rug.nl"
        },
        "short_description": "Uncover the fascinating relationship between connected tropical sets and interval graphs by exploring the number of minimal connected tropical sets within these structured graph types, aiming for both exact calculations in small cases and generalized bounds for larger instances.",
        "long_description": "
Suppose the vertices of a graph G are colored. We define a subset of vertices as a connected tropical set if it generates a connected graph that contains vertices of all colors from the original graph. A subset of vertices is a Minimal Connected Tropical Set if it is a Connected Tropical Set and it does not contain a smaller set that is also a Connected Tropical Set.


A graph is called an interval graph if we can assign intervals on the line to all vertices such that two vertices are adjacent if and only if corresponding intervals intersect.


The objective of this project is to investigate the number of minimal connected tropical sets in interval graphs. We aim to find the exact values of the number of minimal connected tropical sets in small interval graphs using computational resources. We also try to generalize our findings to interval graphs of arbitrary size by providing lower bounds or upper bounds on their value.


Below you can find literature that is relevant to this project:

-    [Enumerating Minimal Tropical Connected Set](https://link.springer.com/chapter/10.1007/978-3-319-51963-0_17)

-    [Enumeration of Minimal Tropical Connected Sets](https://link.springer.com/chapter/10.1007/978-3-031-30448-4_10)
",
        "tags": ["algorithms", "graphs"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "Theory and Practice of Bidirectional Typechecking",
        "supervisor": {
            "name": "Dan Frumin",
            "email": "d.frumin@rug.nl"
        },
        "short_description": "Study and build modern mechanisms for type-checking programming lanagues with higher-order features.",
        "long_description": "
This project is about implementing a type system for a programming language. A type system determines which programs in a programming language are valid, and which ones are not.  A type system for example can reject a program that adds a number and a string together, thus catching a type error. And more advanced type system can catch more errors. The process of enforcing such a typing discipline is called type checking: given a program, annotated with types, a compiler checks whether to accept the program or reject it.


The natural question for implementers of compilers is then how to implement a type system, without requiring too much input from the user. That is, given a partially annotated program, can we infer the types? This is referred to as type inference.


One class of algorithms for implementing type systems are based on bidirectional type checking, which combines type checking and type inference into a straightforward algorithm.


The goal of this project is to study bidirectional type checking and implementing one of the algorithms in your favorite programming language.


If you enjoyed the courses on functional programming or the elective course on compiler construction, then this project might be for you!

Additional reading: [Bidirectional Typing Rules: A Tutorial](https://davidchristiansen.dk/tutorials/bidirectional.pdf) and [Lecture Notes on Bidirectional Typechecking](https://www.cs.cmu.edu/~fp/courses/15312-f04/handouts/15-bidirectional.pdf)
",
        "tags": ["type systems", "programming languages"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "FitchVIZIER: Improvements and extensions",
        "supervisor": {
            "name": "Dan Frumin",
            "email": "d.frumin@rug.nl"
        },
        "short_description": "",
        "long_description": "
FitchVIZIER is a proof checker for Fitch-style proofs written in Rust and used in the course \"Introduction to Logic\" in the CS and AI programs.
This project concerns possible improvements and extensions, raging from mostly practical to mostly theoretical.
The idea is the during the course of this bachelor project you will study the topic from the theoretical point of view and implement it in FitchVIZIER.

Given the context, this project is suitable for students who are interested and have some experience with logic and Rust.

Potential improvements/extensions are:

- Support for external theorems and a module system

- An implementaiton of proofs by induction and unification

- Support for \"partial\" proofs

- Conversaion between Fitch-style and Gentzen-style proof systems
",
        "tags": ["logic", "programming"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "Formally verified functional programs in Rocq",
        "supervisor": {
            "name": "Dan Frumin",
            "email": "d.frumin@rug.nl"
        },
        "short_description": "Study purely-functional data structrues and prove their correctness.",
        "long_description": "
       The aim of this project is to build a formally verified correct software, and to familiarize yourself with the Rocq system. Rocq is a proof assistant and a programming language, which allows the user not only to write and execute functional programs, but also to prove properties about them.


In the first part of this programming project the student will first familiarize themselves with the basics of Rocq. In the second part, the student will pick an algorithm or a data structure – for example, a queue, a look-up table, a binary tree, etc – and they will implement and verify it.


Required skills: Knowledge of functional programming and mathematical induction


Here are some more links that contextualize the project:

- [Introduction to the Coq proof-assistant for practical software verification](https://www.lri.fr/~paulin/LASER/course-notes.pdf)

- A book on [Verified Functinal Algorithms](https://softwarefoundations.cis.upenn.edu/vfa-current/index.html)

- See also the [previous student projects](past-projects.html) on this topic.
",
        "tags": ["logic", "functional programming", "verification"],
        "category": "BSc",
        "available": 2
    },


    {
        "title": "Algebraic Effects and Handlers",
        "supervisor": {
            "name": "Dan Frumin",
            "email": "d.frumin@rug.nl"
        },
        "short_description": "Algebriac Effects are a recent programming paradigm for handling effects in functional programming languages",
        "long_description": "
Algebraic Effects is a formal system for describing and programming with side-effects in functional programming. They generalize a large class of familiar effects (like I/O, exceptions, mutable state), while allowing for compositional and modular programming and reasoning. In the paradigm of algebraic effects, specific side effects can be encoded using algebraic abstractions (hence the name) and treated as first-class objects with the use of handlers.

While originating in theoretical computer science, algebraic effects have been implemented most notably as part of the latest release of the OCaml programming language, where they are used for the implementation of the concurrent subsystem.

The goal of this project is to study both the theoretical foundations of algebraic effects, as well as the practice of programming with algebraic effects in OCaml.
To this end, the student is  to investigate the mathematical foundations of algebraic effects, and report on how it is connected with the practice of programming.

At the end the student is expected to provide a report, which can serve as a guide to algebraic effects for fellow students who might be interested in the topic, as well as a collection of examples written in OCaml.

Some relevant reading:

- [An Introduction to Algebraic Effects and Handlers](https://www.eff-lang.org/handlers-tutorial.pdf)

- [Programming with Algebraic Effects and Handlers](https://arxiv.org/pdf/1203.1539)

- [OCaml Language Manual: Effect Handlers](https://ocaml.org/manual/5.4/effects.html)

- [Effective Programming: Adding an Effect System to OCaml](https://www.janestreet.com/tech-talks/effective-programming/)

- [Friendship ended with Monads: Testing out Algebraic effects in OCaml for Animations](https://gopiandcode.uk/logs/log-bye-bye-monads-algebraic-effects.html)

- [What is algebraic about algebraic effects and handlers?](https://arxiv.org/abs/1807.05923)

",
        "tags": ["type theory", "functional programming"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "Gradual Typing and Its Guarantees",
        "supervisor": {
            "name": "Dan Frumin",
            "email": "d.frumin@rug.nl"
        },
        "short_description": ".",
        "long_description": "....",
        "tags": ["type theory", "functional programming"],
        "category": "BSc",
        "available": 1
    },


    {
        "title": "Reasoning about clients and servers using logic",
        "supervisor": {
            "name": "Jorge Pérez",
            "email": "j.a.perez@rug.nl"
        },
        "short_description": "Learn how to formally verify client-server programs using logic!",
        "long_description": "
This project concerns formal languages able to express concurrency, in the form of processes that execute simultaneously and interact with each other by exchanging messages. We are particularly interested in message-passing processes that follow a client-server architecture, where client processes send a message to invoke some server process that provides some useful functionality and is always available. This kind of client-server interaction is very common in practice, and it is important to have precise tools to reason about the correct behavior of clients and servers. 

Interestingly, logic can provide a precise setting to reason about clients, servers, and their intended interactions. This project concerns [linear logic](https://en.wikipedia.org/wiki/Linear_logic), a type of logic that tracks resources used by processes, in which client-server interactions can be neatly represented. There are several seemingly related logical characterizations of client-server interactions using linear logic; the goal of this project is to study the most important characterizations and to compare their most relevant characteristics by means of examples. 

In this project you will learn about models of concurrency, static verification (type systems), and the Curry-Howard correspondence: a beautiful connection between static verification and logic. 
See <https://www.jperez.nl/teaching/projects> for a list of suggested pointers. 


**Deliverables:**
A written report, in the style of a scientific paper, that surveys in a self-contained manner different characterizations of client-sever interactions using linear logic.
",
        "tags": ["type systems", "concurrency", "logic"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "The Dining Philosophers in APCP",
        "supervisor": {
            "name": "Jorge Pérez",
            "email": "j.a.perez@rug.nl"
        },
        "short_description": "Learn to formally verify a classic concurrency scenario using logic",
        "long_description": "
This project concerns formal languages able to express concurrency, in the form of processes that execute simultaneously and interact with each other by exchanging messages. In particular, we are interested in APCP, a formal language in which message-passing processes implement protocols. In prior research, we have determined the formal conditions under which programs in APCP execute their protocols without running into a deadlock: the situation in which a program is stuck waiting for a message that will never arrive. We have used [linear logic](https://en.wikipedia.org/wiki/Linear_logic), a type of logic that tracks resources used by APCP processes, to ensure freedom from deadlocks.

We have already demonstrated the power of APCP in different scenarios that involve concurrency. The goal of this project is to complement this work by developing an APCP program that implements a solution to [Dijkstra's Dining Philosophers problem](https://en.wikipedia.org/wiki/Dining_philosophers_problem), one of the most famous problems in concurrent programming. Concretely, in this project you will use APCP to implement a solution to the problem based on a resource hierarchy. That is, you will develop an implementation of the dining philosophers that exploits concurrent synchronizations and prove that it never runs into deadlocks. 

In this project you will learn about models of concurrency, static verification (type systems), and the Curry-Howard correspondence: a beautiful connection between static verification and logic. 
See <https://www.jperez.nl/teaching/projects> for a list of suggested pointers.


**Deliverables:**
A written report, in the style of a scientific paper, that presents your verified implementation of the Dining Philosophers problem in APCP. 

",
        "tags": ["concurrency", "type systems", "formal verification"],
        "category": "BSc",
        "available": 1
    },

    {
        "title": "Upper Bounds for Concurrent Asynchronous Programs in APCP",
        "supervisor": {
            "name": "Jorge Pérez",
            "email": "j.a.perez@rug.nl"
        },
        "short_description": "Learn to formally reason about resource usage in concurrency using types and logic",
        "long_description": "
This project concerns formal languages able to express concurrency, in the form of processes that execute simultaneously and interact with each other by exchanging messages. In particular, we are interested in APCP, a formal language in which message-passing processes implement protocols. These protocols are specified using session types, which describe structures of intended communication. Communication in APCP is asynchronous: a data structure called buffers is used to store messages that have been sent but not yet received. 

Prior work by Gay and Vasconcelos (for a language similar to APCP) showed that one can obtain an upper bound on the necessary size of the buffers (see [here](https://www.di.fc.ul.pt/~vv/papers/gay.vasconcelos_linear-sessions.pdf)). Intuitively, the idea is to examine the intended protocol, and to derive an upper bound for a buffer using the protocol’s size. This informally means that a protocol with n message exchanges will require a larger buffer than the one needed to implement a protocol with k message exchanges, for any k < n. The goal of this project is to adapt the argument by Gay and Vasconcelos to the case of APCP. This entails studying the definitions and proofs by Gay and Vasconcelos and to check whether/how they apply to the case of APCP, in which session types are closely related to [linear logic](https://en.wikipedia.org/wiki/Linear_logic), a type of logic that tracks resources used by processes. 

In this project you will learn about models of concurrency, static verification (type systems), and the Curry-Howard correspondence: a beautiful connection between static verification and logic. 
See <https://www.jperez.nl/teaching/projects> for a list of suggested pointers.


**Deliverables:**
A written report, in the style of a scientific paper, that presents your formal analysis (definitions and proofs) for the upper bound of buffers in APCP. 
",
        "tags": ["concurrency", "type systems", "formal verification", "logic"],
        "category": "BSc",
        "available": 1
    },



    {
        "title": "Well-quasi-orderings in computer science and their upper bounding",
        "supervisor": {
            "name": "Revantha Ramanayake",
            "email": "d.r.s.ramanayake@rug.nl"
        },
        "short_description": "...",
        "long_description": "Let N be the set of natural numbers {0, 1, 2, .. }. Consider the binary relation <= on N^2 = { (x,y) | x ∈ N and y ∈ N } defined as:


(a1, b1) <= (a2, b2) iff a1 <= a2 and b1 <= b2


For example, (2, 2) <= (3, 3) but (2,2) and (3, 1) are incomparable under <=. It is easy to see that <= is reflexive and transitive i.e., it is a quasi-order.


A bad sequence is a sequence a0, a1, a2, .. of elements from N^2 with the property that there is no increasing pair i.e. there is no i,j with i < j such that ai <= aj. An example of a bad sequence is (2,2), (3,1), (1,1), (0,1). However, (2,2), (1,3),(3,2) is not a bad sequence since it contains an increasing pair (2,2) <= (3,2). 


It is easy to see that a bad sequence on N is finite since it would have to be a strictly descending sequence (e.g. 7, 5, 3, 2, 1, 0). The existence of incomparable elements in N^2 under <= makes the situation more interesting. Nevertheless:


LEMMA. Every bad sequence on N^2 with respect to <= is finite. 

(Can you prove it? What is an example of a set and ordering where infinite bad sequences exist?)


A quasi-ordering <= such that every bad sequence is finite is called a well-quasi-ordering (wqo).


What is the maximum length of a bad sequence on N^2? It does not exist, since arbitrarily large jumps can be made e.g., (2,2), (1, 100), (1, 99), .. and hence arbitrarily long bad sequences can be found. However, if we restrict the size of a jump, e.g. \\|a_{I+1}\\| <= 2.\\|a_i\\| where \\|a\\| is the maximum value over the coordinates then it can be shown that a maximum length for bad sequences exists as a function of the starting element (can you prove it? can you compute its length under this doubling control?).


RELATIONSHIP TO TCS: Suppose you want to show that an algorithm terminates. In many cases, the successive configurations of the algorithm can be represented as a bad sequence of some wqo. In such cases, the finiteness of the bad sequence guarantees termination, and the length of the bad sequence provides an upper bound.


In 2011, Figueira et al. gave an elementary and self-contained proof of sharp upper bounds for controlled bad sequences over N^k. The aim of this project is to survey the application of wqos in theoretical computer science and to survey their upper bound argument.


This topic is suited to a student who is interested in the mathematical aspects of computer science. The starting reference is the following.

Diego Figueira, Santiago Figueira, Sylvain Schmitz, Philippe Schnoebelen: Ackermannian and Primitive-Recursive Bounds with Dickson's Lemma. ACM/IEEE Symposium on Logic in Computer Science LICS 2011: 269-278",
        "tags": ["logic", "complexity"],
        "available": 1,
        "category": "BSc",
    },
]
